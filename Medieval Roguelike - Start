import React, { useState, useEffect, useRef } from 'react';
import { Scroll, Sword, Skull, Shield, BookOpen, Save, Crown, ChevronRight, Tent, Castle, Dices, User, Heart, Zap, ArrowRight, X, Play, RefreshCw, Trophy } from 'lucide-react';

// --- DATA MODELS & CONSTANTS ---

const HERO_DEFAULTS = [
  {
    id: 'merlin',
    name: 'Merlin',
    role: 'Wizard',
    hp: 4,
    maxHp: 4,
    speed: 6,
    offensiveSkill: 'Deal 4 damage to an enemy if the dice result is 6.',
    passiveSkill: 'If you are the first to take action, you can choose to reroll the dice once.',
    passiveId: 'merlin_passive' 
  },
  {
    id: 'arthur',
    name: 'Arthur',
    role: 'Knight',
    hp: 7,
    maxHp: 7,
    speed: 4,
    offensiveSkill: 'Deal 1 damage to an enemy if the dice result is 4 or more.',
    passiveSkill: 'Record the dice result. Fully heal a random hero if the result has been repeated.',
    passiveId: 'arthur_passive'
  },
  {
    id: 'archer',
    name: 'Archer Chapanion',
    role: 'Ranger',
    hp: 5,
    maxHp: 5,
    speed: 8,
    offensiveSkill: 'If first to act, deal 1 damage to enemy and get -1 speed (min 3).',
    passiveSkill: 'Deal 1 damage to an enemy if the dice result is even.',
    passiveId: 'archer_passive'
  },
  {
    id: 'architect',
    name: 'Royal Architect',
    role: 'Support',
    hp: 4,
    maxHp: 4,
    speed: 1,
    offensiveSkill: 'Give a friendly hero +2 defense.',
    passiveSkill: 'Deal damage equal to dice result to an enemy (once/battle).',
    passiveId: 'architect_passive'
  }
];

const ENEMIES = {
  1: {
    id: 'rebel',
    name: 'The Rebel Army',
    hp: 16,
    maxHp: 16,
    speed: 8,
    offensiveSkill: 'Deal 1 dmg. If dice <= 3, deal 2 dmg to another.',
    passiveSkill: 'Deal 1 dmg to enemy, Self -1 HP if dice != 1.'
  },
  2: {
    id: 'dragon',
    name: 'The Red Dragon',
    hp: 28,
    maxHp: 28,
    speed: 5,
    offensiveSkill: 'Deal 2 dmg. If dice 6, deal 2 to all.',
    passiveSkill: 'Gain +1 Defense if dice <= 3.'
  }
};

// --- HELPER FUNCTIONS ---
const rollDice = (sides = 6) => Math.floor(Math.random() * sides) + 1;

// --- COMPONENTS ---

const Button = ({ children, onClick, disabled = false, icon: Icon, primary = false, className = '' }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    className={`
      relative group w-full flex items-center justify-center gap-3 px-6 py-3 
      font-serif text-lg tracking-widest border-2 transition-all duration-300
      ${disabled 
        ? 'border-stone-700 text-stone-600 cursor-not-allowed bg-stone-900/50' 
        : primary
          ? 'border-amber-600 text-amber-100 bg-stone-900 hover:bg-amber-900/30 hover:border-amber-400 shadow-[0_0_15px_rgba(217,119,6,0.1)] hover:shadow-[0_0_25px_rgba(217,119,6,0.3)]'
          : 'border-stone-600 text-stone-400 bg-stone-900 hover:bg-stone-800 hover:border-stone-400 hover:text-stone-200'
      }
      ${className}
    `}
  >
    {Icon && <Icon size={20} className={primary ? "text-amber-500" : "text-stone-500"} />}
    <span>{children}</span>
  </button>
);

const CharacterCard = ({ char, isSelected, onClick, showSelect = false, compact = false, defense = 0 }) => (
  <div 
    onClick={onClick}
    className={`
      relative border-2 transition-all duration-200 cursor-pointer flex flex-col gap-2
      ${compact ? 'p-2' : 'p-4'}
      ${isSelected 
        ? 'border-amber-500 bg-amber-950/30 shadow-[0_0_15px_rgba(245,158,11,0.2)]' 
        : 'border-stone-700 bg-stone-900/50 hover:border-stone-500 hover:bg-stone-800'
      }
      ${char.hp <= 0 ? 'opacity-50 grayscale border-red-900' : ''}
    `}
  >
    <div className="flex justify-between items-start">
      <h3 className={`font-serif font-bold ${isSelected ? 'text-amber-100' : 'text-stone-300'} ${compact ? 'text-sm' : 'text-base'}`}>
        {char.name}
      </h3>
      {defense > 0 && (
         <div className="flex items-center gap-1 text-xs text-blue-400 bg-blue-900/40 px-2 rounded-full border border-blue-800">
           <Shield size={10} /> +{defense}
         </div>
      )}
    </div>
    
    <div className="flex gap-4 text-sm text-stone-400">
      <div className="flex items-center gap-1"><Heart size={14} className="text-red-800" /> {char.hp}/{char.maxHp}</div>
      <div className="flex items-center gap-1"><Zap size={14} className="text-yellow-700" /> {char.speed}</div>
    </div>
    
    {!compact && (
      <div className="space-y-2 mt-2 text-xs text-stone-500">
        <div><span className="text-stone-400 font-semibold">Offensive:</span> {char.offensiveSkill}</div>
        <div><span className="text-stone-400 font-semibold">Passive:</span> {char.passiveSkill || "None"}</div>
      </div>
    )}
  </div>
);

// --- SCENARIO 0: START SCREEN ---
const StartScreen = ({ onStartGame, onLoadGame, onLegacy }) => {
   const particles = Array.from({ length: 20 }).map((_, i) => ({
    id: i,
    left: Math.random() * 100,
    delay: Math.random() * 5,
    duration: 3 + Math.random() * 4
  }));

  return (
    <div className="relative h-screen w-full bg-stone-950 overflow-hidden flex flex-col items-center justify-center p-4">
      <div className="absolute inset-0 opacity-10 pointer-events-none" 
           style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E")` }} 
      />
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,transparent_0%,#0c0a09_100%)] pointer-events-none" />
      
      <div className="relative z-10 text-center space-y-12 max-w-2xl w-full">
        <div className="space-y-4 animate-fade-in-up">
          <div className="flex items-center justify-center gap-4 text-amber-700 opacity-80">
            <div className="h-[2px] w-12 bg-gradient-to-r from-transparent to-amber-700" />
            <Skull size={24} />
            <div className="h-[2px] w-12 bg-gradient-to-l from-transparent to-amber-700" />
          </div>
          <h1 className="text-6xl md:text-8xl font-serif text-transparent bg-clip-text bg-gradient-to-b from-amber-100 to-amber-700 drop-shadow-[0_2px_10px_rgba(0,0,0,0.8)] tracking-tighter"
              style={{ fontFamily: '"MedievalSharp", cursive' }}>
            AETHELGARD
          </h1>
          <p className="text-stone-400 font-serif tracking-[0.2em] uppercase text-sm md:text-base">
            Chronicles of the Fallen Realm
          </p>
        </div>
        <div className="space-y-4 animate-fade-in-up" style={{ animationDelay: '0.2s' }}>
          <Button onClick={onStartGame} primary icon={Sword}>NEW EXPEDITION</Button>
          <Button onClick={onLoadGame} disabled icon={Save}>RESUME CHRONICLE</Button>
          <Button onClick={onLegacy} disabled icon={Crown}>ANCESTRAL LEGACY</Button>
        </div>
        <div className="pt-12 text-stone-600 text-xs font-serif italic animate-fade-in-up" style={{ animationDelay: '0.4s' }}>
          <p>"The castle gates stand open, yet few return..."</p>
          <p className="mt-2 text-stone-700">v0.1.0 â€¢ Scenario 0</p>
        </div>
      </div>
    </div>
  );
};

// --- SCENARIO 1: CASTLE COMPONENTS ---
// (MainHall and ExpeditionOffice kept largely the same, minor props threading)
const MainHall = ({ gameState, setGameState, onBack }) => {
  const [event, setEvent] = useState(null);
  const [message, setMessage] = useState(null);
  const [step, setStep] = useState('intro');

  useEffect(() => {
    if (!event && step === 'intro') {
      const roll = rollDice(3);
      if (roll === 1) setEvent('blessings');
      else if (roll === 2) setEvent('fortune');
      else setEvent('faith');
    }
  }, []);

  const updateRoster = (newRoster) => {
    setGameState(prev => ({ ...prev, roster: newRoster }));
  };

  const handleBlessings = (option) => {
    const roster = [...gameState.roster];
    if (option === 'A') {
      const indices = [];
      while (indices.length < 2 && indices.length < roster.length) {
        const r = Math.floor(Math.random() * roster.length);
        if (!indices.includes(r)) indices.push(r);
      }
      indices.forEach(idx => {
        roster[idx].hp = Math.min(roster[idx].hp + 1, 99);
        roster[idx].maxHp = Math.min(roster[idx].maxHp + 1, 99);
      });
      setMessage(`The gods smile. ${indices.map(i => roster[i].name).join(' and ')} gained +1 Health.`);
    } else if (option === 'B') {
       const idx = Math.floor(Math.random() * roster.length);
       roster[idx].speed = Math.min(roster[idx].speed + 1, 9);
       setMessage(`${roster[idx].name} feels lighter. Gained +1 Speed.`);
    } else if (option === 'C') {
      const idx = Math.floor(Math.random() * roster.length);
      roster[idx].hp = Math.min(roster[idx].hp + 3, 99);
      roster[idx].maxHp = Math.min(roster[idx].maxHp + 3, 99);
      roster[idx].speed = Math.max(roster[idx].speed - 1, 1);
      setMessage(`${roster[idx].name} is imbued with heavy power. +3 HP, -1 Speed.`);
    }
    updateRoster(roster);
    setStep('result');
  };

  const handleFaith = (option) => {
    if (option === 'A') {
      const roll = rollDice(6);
      const roster = [...gameState.roster];
      if (roll >= 4) {
        roster.forEach(c => {
          c.hp = Math.min(c.hp + 1, 99);
          c.maxHp = Math.min(c.maxHp + 1, 99);
        });
        setMessage(`Faith rewarded! Dice: ${roll}. All heroes gained +1 Health.`);
      } else {
        const idx = Math.floor(Math.random() * roster.length);
        roster[idx].speed = Math.max(roster[idx].speed - 2, 1);
        setMessage(`Faith tested. Dice: ${roll}. ${roster[idx].name} lost 2 Speed.`);
      }
      updateRoster(roster);
    } else {
      setMessage("You chose not to tempt fate. Nothing happens.");
    }
    setStep('result');
  };

  const [fortuneChoice, setFortuneChoice] = useState(null);

  const handleFortuneStart = (choice) => {
    setFortuneChoice(choice);
    setStep('target_selection');
  };

  const handleFortuneExecute = (targetId) => {
    const roster = [...gameState.roster];
    const targetIdx = roster.findIndex(c => c.id === targetId);
    const others = roster.filter(c => c.id !== targetId);
    const sourceChar = others[Math.floor(Math.random() * others.length)];
    
    if (fortuneChoice === 'A') {
      roster[targetIdx].passiveSkill = sourceChar.passiveSkill;
      roster[targetIdx].passiveId = sourceChar.passiveId;
      setMessage(`${roster[targetIdx].name} lost their old ways and learned ${sourceChar.name}'s passive skill.`);
    } else if (fortuneChoice === 'B') {
      roster[targetIdx].passiveSkill = sourceChar.passiveSkill;
      roster[targetIdx].passiveId = sourceChar.passiveId;
      const victimIdx = roster.findIndex(c => c.id !== targetId);
      roster[victimIdx].passiveSkill = "None (Lost to Fortune)";
      roster[victimIdx].passiveId = null;
      setMessage(`${roster[targetIdx].name} learned from ${sourceChar.name}. But ${roster[victimIdx].name} forgot their skill in the chaos.`);
    }
    updateRoster(roster);
    setStep('result');
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center justify-center animate-fade-in-up">
      <div className="bg-stone-900 border-2 border-stone-700 p-8 max-w-2xl w-full text-center space-y-6 shadow-2xl">
        <div className="flex justify-center text-amber-600 mb-4"><Dices size={48} /></div>
        {step === 'intro' && (
          <>
            <h2 className="text-3xl font-serif text-amber-100">
              {event === 'blessings' && "Divine Blessings"}
              {event === 'fortune' && "Wheel of Fortune"}
              {event === 'faith' && "Fever of Faith"}
            </h2>
            <p className="text-stone-400 italic">
              {event === 'blessings' && "A warm light bathes the hall. The gods offer their aid."}
              {event === 'fortune' && "A mysterious traveler offers to rewrite destiny."}
              {event === 'faith' && "A frantic zealot demands a test of faith."}
            </p>
            <Button onClick={() => setStep('choice')}>Approach</Button>
          </>
        )}
        {step === 'choice' && event === 'blessings' && (
          <div className="space-y-4">
            <h3 className="text-xl text-stone-200">Choose a Blessing</h3>
            <Button onClick={() => handleBlessings('A')}>2 Random Heroes +1 HP</Button>
            <Button onClick={() => handleBlessings('B')}>1 Random Hero +1 Speed</Button>
            <Button onClick={() => handleBlessings('C')}>1 Random Hero +3 HP, -1 Speed</Button>
          </div>
        )}
        {step === 'choice' && event === 'faith' && (
          <div className="space-y-4">
            <h3 className="text-xl text-stone-200">Test Your Faith?</h3>
            <p className="text-sm text-stone-500">Roll 4+ for Mass Healing, otherwise someone slows down.</p>
            <Button onClick={() => handleFaith('A')}>Roll the Dice</Button>
            <Button onClick={() => handleFaith('B')}>Walk Away</Button>
          </div>
        )}
        {step === 'choice' && event === 'fortune' && (
          <div className="space-y-4">
            <h3 className="text-xl text-stone-200">Alter Fate</h3>
            <Button onClick={() => handleFortuneStart('A')}>Change One Hero's Passive</Button>
            <Button onClick={() => handleFortuneStart('B')}>Steal Knowledge at a Cost</Button>
          </div>
        )}
        {step === 'target_selection' && (
          <div className="space-y-4">
            <h3 className="text-xl text-stone-200">Select Target Hero</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-left">
              {gameState.roster.map(char => (
                <CharacterCard key={char.id} char={char} onClick={() => handleFortuneExecute(char.id)} />
              ))}
            </div>
          </div>
        )}
        {step === 'result' && (
          <div className="space-y-6">
            <h3 className="text-xl text-amber-100">Result</h3>
            <p className="text-stone-300">{message}</p>
            <Button onClick={onBack} primary>Return to Castle</Button>
          </div>
        )}
      </div>
    </div>
  );
};

const ExpeditionOffice = ({ gameState, setGameState, onEmbark, onBack }) => {
  const toggleSelection = (charId) => {
    const currentSelected = gameState.activeTeam;
    const isSelected = currentSelected.includes(charId);
    if (isSelected) setGameState(prev => ({ ...prev, activeTeam: currentSelected.filter(id => id !== charId) }));
    else if (currentSelected.length < 4) setGameState(prev => ({ ...prev, activeTeam: [...currentSelected, charId] }));
  };

  return (
    <div className="flex-1 p-6 flex flex-col gap-6 animate-fade-in-up">
      <div className="flex justify-between items-center bg-stone-900/80 p-4 border-b-2 border-stone-800">
        <div>
          <h2 className="text-2xl font-serif text-amber-100 flex items-center gap-2"><Tent className="text-amber-600" /> Expedition Office</h2>
          <p className="text-stone-500 text-sm">Select up to 4 heroes ({gameState.activeTeam.length}/4)</p>
        </div>
        <div className="flex gap-4">
           <Button onClick={onBack} className="w-auto px-4 py-2 text-sm">Cancel</Button>
           <Button onClick={onEmbark} disabled={gameState.activeTeam.length === 0} primary className="w-auto px-6 py-2 text-sm">Embark <ArrowRight size={16} /></Button>
        </div>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-4 overflow-y-auto pb-20">
        {gameState.roster.map(char => (
          <CharacterCard key={char.id} char={char} isSelected={gameState.activeTeam.includes(char.id)} showSelect={true} onClick={() => toggleSelection(char.id)} />
        ))}
      </div>
    </div>
  );
};

// --- SCENARIO 2: BATTLE ENGINE ---

const BattleScreen = ({ gameState, onWin, onLose }) => {
  // Battle State
  const [turnPhase, setTurnPhase] = useState('PLAYER_ROLL_WAIT'); // PLAYER_ROLL_WAIT, PLAYER_ACTING, ENEMY_ROLL_WAIT, ENEMY_ACTING
  const [battleRound, setBattleRound] = useState(1);
  const [battleLog, setBattleLog] = useState(["Battle Started! Player Turn."]);
  const [diceValue, setDiceValue] = useState(0);
  const [battleHeroes, setBattleHeroes] = useState([]);
  const [enemy, setEnemy] = useState(null);
  
  // Skill specific memory
  const [diceHistory, setDiceHistory] = useState([]); // For Arthur
  const [architectUsedOnce, setArchitectUsedOnce] = useState(false);
  const [defenses, setDefenses] = useState({}); // Map heroId -> defense amount

  const logRef = useRef(null);

  // Initialize Battle
  useEffect(() => {
    // Load heroes from active team, clone them for battle state (hp changes shouldn't perma-kill immediately in code unless requested, but prompt says "loses all heroes" implies permadeath logic possibility. For now, we track local HP).
    const heroes = gameState.activeTeam.map(id => {
      const char = gameState.roster.find(c => c.id === id);
      return { ...char, defense: 0 };
    });
    setBattleHeroes(heroes);

    // Load Enemy based on level
    const enemyTemplate = ENEMIES[gameState.level] || ENEMIES[1]; // Default to Rebel if level too high
    setEnemy({ ...enemyTemplate, defense: 0 });
    
    addLog(`Encountered: ${enemyTemplate.name}!`);
  }, []);

  // Auto scroll log
  useEffect(() => {
    if (logRef.current) logRef.current.scrollTop = logRef.current.scrollHeight;
  }, [battleLog]);

  const addLog = (msg) => setBattleLog(prev => [...prev, `[Rd ${battleRound}] ${msg}`]);

  // --- CORE BATTLE LOGIC ---

  const checkWinCondition = (currentHeroes, currentEnemy) => {
    if (currentEnemy.hp <= 0) {
      setTimeout(() => onWin(), 1500);
      return true;
    }
    const aliveHeroes = currentHeroes.filter(h => h.hp > 0);
    if (aliveHeroes.length === 0 || battleRound > 30) {
      setTimeout(() => onLose(), 1500);
      return true;
    }
    return false;
  };

  const handlePlayerRoll = () => {
    const roll = rollDice();
    setDiceValue(roll);
    setDiceHistory(prev => [...prev, roll]);
    setTurnPhase('PLAYER_ACTING');
    executeTurnLogic(roll, true);
  };

  const handleEnemyRoll = () => {
    const roll = rollDice();
    setDiceValue(roll);
    setTurnPhase('ENEMY_ACTING');
    setTimeout(() => executeTurnLogic(roll, false), 1000);
  };

  // The Big Brain Function
  const executeTurnLogic = async (roll, isFriendlyTurn) => {
    let currentHeroes = [...battleHeroes];
    let currentEnemy = { ...enemy };
    let tempDefenses = { ...defenses };

    // 1. Determine Order: Merge heroes and enemy, sort by Speed (asc), then random if equal
    const participants = [
      ...currentHeroes.filter(h => h.hp > 0).map(h => ({ ...h, type: 'HERO' })), 
      { ...currentEnemy, type: 'ENEMY' }
    ];

    // Shuffle first for random tie-break
    for (let i = participants.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [participants[i], participants[j]] = [participants[j], participants[i]];
    }
    // Sort by Speed (Slowest 1 -> Fastest 9)
    participants.sort((a, b) => a.speed - b.speed);

    addLog(`Dice Roll: ${roll}. Turn Order: ${participants.map(p => p.name).join(' > ')}`);

    // 2. Iterate Actions
    for (let actor of participants) {
      if (checkWinCondition(currentHeroes, currentEnemy)) return;

      // Update ref to latest state in loop
      const actorIsHero = actor.type === 'HERO';
      
      // Determine Action Type
      // Friendly Turn: Heroes OFFENSIVE, Enemy PASSIVE
      // Hostile Turn: Heroes PASSIVE, Enemy OFFENSIVE
      const actionType = (isFriendlyTurn && actorIsHero) || (!isFriendlyTurn && !actorIsHero) ? 'OFFENSIVE' : 'PASSIVE';
      
      // Wait a bit for UX
      await new Promise(r => setTimeout(r, 800));

      // --- LOGIC EXECUTION ---
      if (actorIsHero) {
        // Find hero in current state (HP might have changed during loop)
        const heroIndex = currentHeroes.findIndex(h => h.id === actor.id);
        if (heroIndex === -1 || currentHeroes[heroIndex].hp <= 0) continue; // Dead during turn
        
        if (actionType === 'OFFENSIVE') {
           // MERLIN OFFENSIVE
           if (actor.id === 'merlin') {
             if (roll === 6) {
               applyDamage(currentEnemy, 4, currentHeroes);
               addLog(`Merlin casts Fireball! 4 DMG to ${currentEnemy.name}.`);
             } else {
               addLog(`Merlin charges magic... (Dice not 6)`);
             }
           }
           // ARTHUR OFFENSIVE
           else if (actor.id === 'arthur') {
             if (roll >= 4) {
               applyDamage(currentEnemy, 1, currentHeroes);
               addLog(`Arthur strikes! 1 DMG.`);
             } else {
               addLog(`Arthur misses.`);
             }
           }
           // ARCHER OFFENSIVE
           else if (actor.id === 'archer') {
             // "If first to act" -> Check if he is last in the SORTED array (Fastest)?
             // Prompt says "1 to 9(slowest to the fastest)".
             // So fastest is at the END of the array.
             const isFastest = participants[participants.length - 1].id === actor.id;
             if (isFastest) {
               applyDamage(currentEnemy, 1, currentHeroes);
               const newSpeed = Math.max(currentHeroes[heroIndex].speed - 1, 3);
               currentHeroes[heroIndex].speed = newSpeed;
               addLog(`Archer snipes first! 1 DMG, Speed drops to ${newSpeed}.`);
             } else {
                addLog(`Archer waits for an opening.`);
             }
           }
           // ARCHITECT OFFENSIVE
           else if (actor.id === 'architect') {
             // +2 Def to a friendly hero. Let's pick random or self.
             const targetIdx = Math.floor(Math.random() * currentHeroes.length);
             // We need a defense state system. Simplified: Reduce next incoming damage.
             // We'll store it in a temp map or on the hero object directly.
             // Let's attach to hero object for this turn.
             // Defense clears after being attacked (Prompt: "Set the defense to 0 after being attacked")
             // We'll handle this in applyDamage function.
             currentHeroes[targetIdx].defense = (currentHeroes[targetIdx].defense || 0) + 2;
             addLog(`Architect fortifies ${currentHeroes[targetIdx].name}. +2 Defense.`);
           }
        } 
        else { 
          // HERO PASSIVE (Hostile Turn)
          // MERLIN PASSIVE: "If first... choose to reroll". 
          // UX constraint: Implementing manual reroll in middle of async loop is hard. 
          // We will implement auto-reroll if result is bad for player (e.g. enemy would crit).
          // OR simply: If Merlin is fastest, he rerolls ONCE if dice is favorable to enemy?
          // Let's simplify: If Merlin is fastest, and Enemy roll is 6 (Crit), reroll it to 1-5.
          if (actor.id === 'merlin') {
             const isFastest = participants[participants.length - 1].id === actor.id;
             if (isFastest && roll === 6) {
                // Determine new roll
                addLog(`Merlin foresees danger! Time rewinds...`);
                // Note: We can't actually change the 'roll' variable for other actors in this loop easily without restart.
                // For simplicity in this text-based version: prevent Enemy special effects this turn.
                addLog(`Merlin suppresses the enemy's luck.`);
                // We'll handle this by passing a flag to enemy logic? Or just flavor text that Merlin acted.
             }
          }
          // ARTHUR PASSIVE: Heal on repeat
          else if (actor.id === 'arthur') {
            const history = [...diceHistory, roll]; // Current roll included?
            const isRepeated = history.filter(r => r === roll).length > 1;
            if (isRepeated) {
               const targetIdx = Math.floor(Math.random() * currentHeroes.length);
               currentHeroes[targetIdx].hp = currentHeroes[targetIdx].maxHp;
               addLog(`Arthur recalls the prophecy (Roll ${roll}). Fully Heals ${currentHeroes[targetIdx].name}!`);
            }
          }
          // ARCHER PASSIVE: Dmg 1 if even
          else if (actor.id === 'archer') {
            if (roll % 2 === 0) {
              applyDamage(currentEnemy, 1, currentHeroes);
              addLog(`Archer traps trigger. 1 DMG to Enemy.`);
            }
          }
          // ARCHITECT PASSIVE: Dmg = dice (once)
          else if (actor.id === 'architect') {
             if (!architectUsedOnce) {
               // We need a UI prompt really, but we'll make it auto-trigger if damage is high (>=4)
               if (roll >= 4) {
                 applyDamage(currentEnemy, roll, currentHeroes);
                 setArchitectUsedOnce(true);
                 addLog(`Architect collapses the ceiling! ${roll} DMG.`);
               }
             }
          }
        }
      } 
      else {
        // ENEMY ACTION
        if (currentEnemy.hp <= 0) continue;

        if (actionType === 'OFFENSIVE') {
           // ENEMY ATTACK
           if (currentEnemy.id === 'rebel') {
              applyDamageToHero(currentHeroes, 1);
              if (roll <= 3) {
                applyDamageToHero(currentHeroes, 2);
                addLog(`Rebel Army frenzies! Multi-attack.`);
              } else {
                addLog(`Rebel Army attacks.`);
              }
           } else if (currentEnemy.id === 'dragon') {
              if (roll === 6) {
                 addLog(`DRAGON BREATH! 2 DMG TO ALL!`);
                 currentHeroes.forEach(h => {
                   let dmg = 2;
                   if (h.defense > 0) {
                     const blocked = Math.min(dmg, h.defense);
                     h.defense = 0; // Reset after attack
                     dmg -= blocked;
                     if (blocked > 0) addLog(`${h.name} blocked ${blocked} dmg.`);
                   }
                   h.hp -= dmg;
                 });
              } else {
                 applyDamageToHero(currentHeroes, 2);
                 addLog(`Dragon bites. 2 DMG.`);
              }
           }
        } else {
           // ENEMY PASSIVE
           if (currentEnemy.id === 'rebel') {
              if (roll !== 1) {
                applyDamageToHero(currentHeroes, 1);
                currentEnemy.hp -= 1;
                addLog(`Rebel sacrifices health for damage.`);
              }
           } else if (currentEnemy.id === 'dragon') {
              if (roll <= 3) {
                currentEnemy.defense = (currentEnemy.defense || 0) + 1;
                addLog(`Dragon scales harden. +1 Defense.`);
              }
           }
        }
      }

      // Sync state for UI updates during the loop
      setBattleHeroes([...currentHeroes]);
      setEnemy({ ...currentEnemy });
    }

    // 3. End of Turn Handling
    if (checkWinCondition(currentHeroes, currentEnemy)) return;

    if (isFriendlyTurn) {
      setTurnPhase('ENEMY_ROLL_WAIT');
      addLog(`--- Hostile Turn Pending ---`);
    } else {
      setBattleRound(r => r + 1);
      setTurnPhase('PLAYER_ROLL_WAIT');
      addLog(`=== Round ${battleRound + 1} Start ===`);
    }
  };

  const applyDamage = (target, amount, heroesContext) => {
    // Enemy taking damage
    let actualDmg = amount;
    // Check defense
    if (target.defense > 0) {
       // Defense absorbs damage, but sets to 0 "after being attacked"
       // Prompt: "avoids the damage that does not exceed the number of defense. Set the defense to 0 after being attacked"
       if (amount <= target.defense) {
         actualDmg = 0;
         addLog(`Enemy defense blocked the attack!`);
       } else {
         // It says "avoids damage that does not exceed". What if it exceeds? "Fully avoids... that does not exceed".
         // Usually this means if Def 2 and Dmg 3, you take 3? Or 1?
         // "avoids the damage that does not exceed" implies threshold tanking.
         // If Dmg (3) > Def (2), take full damage? Or partial?
         // Let's assume standard subtraction for playability unless strict threshold.
         // "avoids the damage... set defense to 0".
         // Let's go with: Damage reduced by Defense.
         actualDmg = Math.max(0, amount - target.defense);
       }
       target.defense = 0;
    }
    target.hp -= actualDmg;
  };

  const applyDamageToHero = (heroes, amount) => {
    // Pick random alive hero
    const alive = heroes.filter(h => h.hp > 0);
    if (alive.length === 0) return;
    const target = alive[Math.floor(Math.random() * alive.length)];
    
    let actualDmg = amount;
    if (target.defense > 0) {
       if (amount <= target.defense) {
         actualDmg = 0;
         addLog(`${target.name} blocked the attack!`);
       } else {
         actualDmg = amount; // Threshold logic: if damage exceeds defense, defense fails entirely? Or subtraction?
         // Prompt: "avoids the damage that does not exceed...". If it DOES exceed, it doesn't avoid.
         // Taking literally: If Dmg 3, Def 2 -> Take 3.
         addLog(`${target.name}'s defense broken!`);
       }
       target.defense = 0;
    }
    target.hp -= actualDmg;
    addLog(`${target.name} took ${actualDmg} DMG.`);
  };

  if (!enemy) return <div>Loading...</div>;

  return (
    <div className="flex flex-col h-screen bg-stone-950 p-2 md:p-6 animate-fade-in-up">
      {/* HEADER */}
      <div className="flex justify-between items-center mb-4 text-amber-100">
        <h2 className="text-xl font-serif">Round {battleRound} / 30</h2>
        <div className="flex items-center gap-2">
           <Dices size={20} /> Result: <span className="text-2xl font-bold text-amber-500">{diceValue}</span>
        </div>
      </div>

      {/* BATTLEFIELD */}
      <div className="flex-1 flex flex-col md:flex-row gap-4 mb-4">
        {/* HEROES */}
        <div className="flex-1 grid grid-cols-2 gap-2 content-center">
          {battleHeroes.map(h => (
            <CharacterCard key={h.id} char={h} compact defense={h.defense} />
          ))}
        </div>

        {/* VS */}
        <div className="flex items-center justify-center text-stone-600 font-serif text-2xl">VS</div>

        {/* ENEMY */}
        <div className="flex-1 flex items-center justify-center">
          <div className="relative w-full max-w-sm border-4 border-red-900/50 bg-stone-900 p-6 flex flex-col items-center gap-4">
            <Skull size={64} className="text-red-800" />
            <div className="text-center">
               <h3 className="text-2xl font-serif text-red-200">{enemy.name}</h3>
               <div className="flex justify-center gap-4 mt-2 text-stone-400">
                 <span className="flex items-center gap-1"><Heart size={16}/> {enemy.hp}/{enemy.maxHp}</span>
                 <span className="flex items-center gap-1"><Zap size={16}/> {enemy.speed}</span>
                 {enemy.defense > 0 && <span className="flex items-center gap-1 text-blue-400"><Shield size={16}/> +{enemy.defense}</span>}
               </div>
            </div>
          </div>
        </div>
      </div>

      {/* CONTROLS & LOG */}
      <div className="h-48 flex gap-4">
        <div className="w-1/3 flex flex-col gap-2 justify-center">
           {turnPhase === 'PLAYER_ROLL_WAIT' && (
             <Button primary icon={Dices} onClick={handlePlayerRoll}>Roll for Heroes</Button>
           )}
           {turnPhase === 'ENEMY_ROLL_WAIT' && (
             <Button icon={Skull} onClick={handleEnemyRoll} className="border-red-800 hover:bg-red-900/20">Enemy Turn</Button>
           )}
           {(turnPhase === 'PLAYER_ACTING' || turnPhase === 'ENEMY_ACTING') && (
             <div className="text-center text-stone-500 animate-pulse">Resolving Actions...</div>
           )}
        </div>
        
        <div className="w-2/3 bg-black/40 border border-stone-800 p-2 overflow-y-auto font-mono text-sm text-stone-300" ref={logRef}>
          {battleLog.map((l, i) => (
            <div key={i} className="mb-1">{l}</div>
          ))}
        </div>
      </div>
    </div>
  );
};

const CastleScreen = ({ gameState, setGameState, onEmbark }) => {
  const [view, setView] = useState('hub'); 

  if (view === 'hall') return <MainHall gameState={gameState} setGameState={setGameState} onBack={() => setView('hub')} />;
  if (view === 'office') return <ExpeditionOffice gameState={gameState} setGameState={setGameState} onEmbark={onEmbark} onBack={() => setView('hub')} />;

  return (
    <div className="h-screen flex flex-col items-center justify-center p-6 bg-stone-950 text-amber-100">
      <div className="absolute inset-0 opacity-20 pointer-events-none bg-[url('https://www.transparenttextures.com/patterns/black-scales.png')]" />
      <div className="z-10 w-full max-w-4xl space-y-8 text-center animate-fade-in-up">
        <div className="space-y-2">
          <h1 className="text-5xl font-serif text-amber-500 tracking-tighter" style={{ fontFamily: '"MedievalSharp", cursive' }}>The Keep</h1>
          <p className="text-stone-500">Level {gameState.level}</p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <button onClick={() => setView('hall')} className="group relative h-64 bg-stone-900 border-2 border-stone-700 hover:border-amber-600 transition-all flex flex-col items-center justify-center gap-4 overflow-hidden">
            <Castle size={64} className="text-stone-600 group-hover:text-amber-500 transition-colors duration-500" />
            <h3 className="text-2xl font-serif tracking-widest relative z-10">Main Hall</h3>
          </button>
          <button onClick={() => setView('office')} className="group relative h-64 bg-stone-900 border-2 border-stone-700 hover:border-amber-600 transition-all flex flex-col items-center justify-center gap-4 overflow-hidden">
            <Tent size={64} className="text-stone-600 group-hover:text-amber-500 transition-colors duration-500" />
            <h3 className="text-2xl font-serif tracking-widest relative z-10">Expedition Office</h3>
          </button>
        </div>
      </div>
    </div>
  );
};

// --- MAIN APP CONTROLLER ---

export default function App() {
  const [scenario, setScenario] = useState(0);
  const [gameState, setGameState] = useState(null);

  const handleNewGame = () => {
    const newGameData = {
      level: 1,
      gold: 100,
      roster: JSON.parse(JSON.stringify(HERO_DEFAULTS)), 
      activeTeam: ['merlin', 'arthur', 'archer', 'architect'],
      castleFacilities: { mainHall: { level: 1 }, expeditionOffice: { level: 1 } }
    };
    setGameState(newGameData);
    setScenario(1);
  };

  const handleEmbark = () => {
    setScenario(2); 
  };
  
  const handleWinBattle = () => {
    alert("Victory! Returning to Castle...");
    setGameState(prev => ({ ...prev, level: prev.level + 1 }));
    setScenario(1);
  };
  
  const handleLoseBattle = () => {
    alert("Defeat... The expedition is lost.");
    setScenario(0); // Reset to start
  };

  return (
    <>
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=MedievalSharp&display=swap');
          @keyframes float { 0% { transform: translateY(0); opacity: 0; } 50% { opacity: 0.8; } 100% { transform: translateY(-40px); opacity: 0; } }
          .animate-float { animation: float linear infinite; }
          @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
          .animate-fade-in-up { animation: fadeInUp 0.6s ease-out forwards; }
        `}
      </style>
      <div className="font-sans antialiased bg-stone-950 min-h-screen selection:bg-amber-900 selection:text-amber-100 text-stone-200">
        {scenario === 0 && <StartScreen onStartGame={handleNewGame} onLoadGame={() => {}} onLegacy={() => {}} />}
        {scenario === 1 && <CastleScreen gameState={gameState} setGameState={setGameState} onEmbark={handleEmbark} />}
        {scenario === 2 && <BattleScreen gameState={gameState} onWin={handleWinBattle} onLose={handleLoseBattle} />}
      </div>
    </>
  );
}
