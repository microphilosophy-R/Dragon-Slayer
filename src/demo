I'll generate a Python simulation of a card game event system. This demo uses the **Observer Pattern** to handle triggered effects (modifiers that fire at special times).

This implementation features:

1. **`EventManager`**: The central "bus" that broadcasts messages.
2. **`Card`**: The base class for game entities.
3. **Specific Cards**: Examples like a "Berzerker" (gets stronger when damaged) and a "Cleric" (heals when a card is played) to show how different cards listen for different events.

### How this works

1. **Decoupling:** Notice that the `Game` class knows nothing about `Berzerker` or `Cleric`. It simply yells "Damage happened!" (`notify`) into the void. The cards responsible for handling that event pick it up themselves.
2. **Filtering:** Inside `Berzerker.on_damage`, there is an `if` statement. This is crucial. Every listener hears the event, but they must check if the event applies to them (e.g., did *I* take damage, or did someone else?).
3. **Cleanup:** The `TimeWizard` demonstrates a critical part of the pattern: **Unsubscribing**. If you don't unsubscribe when a card dies or leaves play, the game will try to trigger effects on a card that is no longer on the board, often causing crashes.
import enum
from typing import Callable, Dict, List, Any

# 1. Define Event Types
# These are the "special times" modifiers listen for.
class EventType(enum.Enum):
    ON_TURN_START = "on_turn_start"
    ON_CARD_PLAYED = "on_card_played"
    ON_DAMAGE_TAKEN = "on_damage_taken"
    ON_DEATH = "on_death"

# 2. The Event Manager (The "Subject" or "Observable")
# This class manages subscriptions and notifies listeners when events happen.
class EventManager:
    def __init__(self):
        # A dictionary mapping EventTypes to a list of functions (listeners)
        self.listeners: Dict[EventType, List[Callable]] = {
            event_type: [] for event_type in EventType
        }

    def subscribe(self, event_type: EventType, listener: Callable):
        """Adds a function to be called when the event fires."""
        if listener not in self.listeners[event_type]:
            self.listeners[event_type].append(listener)
            print(f"[System] Listener subscribed to {event_type.name}")

    def unsubscribe(self, event_type: EventType, listener: Callable):
        """Removes a listener."""
        if listener in self.listeners[event_type]:
            self.listeners[event_type].remove(listener)

    def notify(self, event_type: EventType, data: Dict[str, Any]):
        """Broadcasts an event to all subscribers."""
        print(f"\n--- EVENT FIRED: {event_type.name} ---")
        if not self.listeners[event_type]:
            print("(No listeners for this event)")
            return

        # Notify all listeners
        for listener in self.listeners[event_type]:
            listener(data)

# 3. The Game State
class Game:
    def __init__(self):
        self.events = EventManager()
        self.turn_count = 0
    
    def start_turn(self):
        self.turn_count += 1
        print(f"\n[Game] Starting Turn {self.turn_count}...")
        # Trigger the ON_TURN_START event
        self.events.notify(EventType.ON_TURN_START, {"turn": self.turn_count})

    def play_card(self, card_name):
        print(f"[Game] Player plays {card_name}")
        # Trigger ON_CARD_PLAYED
        self.events.notify(EventType.ON_CARD_PLAYED, {"card_name": card_name})

    def deal_damage(self, target_name, amount):
        print(f"[Game] Dealing {amount} damage to {target_name}")
        # Trigger ON_DAMAGE_TAKEN
        self.events.notify(EventType.ON_DAMAGE_TAKEN, {"target": target_name, "amount": amount})

# 4. The Cards (The "Observers")
# These objects wait for specific events to trigger their abilities.

class Card:
    def __init__(self, name, game_ref: Game):
        self.name = name
        self.game = game_ref
        self.attack = 1
        self.health = 5

class Berzerker(Card):
    """Effect: When I take damage, gain +2 Attack."""
    def __init__(self, game_ref):
        super().__init__("Orc Berzerker", game_ref)
        # Subscribe to the damage event
        self.game.events.subscribe(EventType.ON_DAMAGE_TAKEN, self.on_damage)

    def on_damage(self, data):
        # Filter: Only trigger if *this* card is the target
        if data['target'] == self.name:
            self.attack += 2
            print(f"   >>> {self.name} Effect: 'RAAAH!' Attack is now {self.attack}")

class Cleric(Card):
    """Effect: Whenever ANY card is played, heal self for 1."""
    def __init__(self, game_ref):
        super().__init__("Holy Cleric", game_ref)
        self.game.events.subscribe(EventType.ON_CARD_PLAYED, self.on_card_played)

    def on_card_played(self, data):
        # We don't care *which* card was played, just that one was.
        self.health += 1
        print(f"   >>> {self.name} Effect: 'Blessings.' Health is now {self.health}")

class TimeWizard(Card):
    """Effect: At the start of turn 2, destroy yourself."""
    def __init__(self, game_ref):
        super().__init__("Time Wizard", game_ref)
        self.game.events.subscribe(EventType.ON_TURN_START, self.on_turn_start)

    def on_turn_start(self, data):
        if data['turn'] == 2:
            print(f"   >>> {self.name} Effect: 'My time has come.' (Dies)")
            # Clean up: Unsubscribe to prevent memory leaks or errors
            self.game.events.unsubscribe(EventType.ON_TURN_START, self.on_turn_start)

# 5. Simulation
if __name__ == "__main__":
    # Setup
    game = Game()
    
    # Create cards (they automatically subscribe on init)
    p1 = Berzerker(game)
    p2 = Cleric(game)
    p3 = TimeWizard(game)

    # --- Simulation Start ---
    
    # 1. Start Turn 1
    game.start_turn()
    
    # 2. Play a random spell
    game.play_card("Fireball") 
    # (Cleric should trigger)

    # 3. Deal damage to Berzerker
    game.deal_damage("Orc Berzerker", 3) 
    # (Berzerker should trigger)

    # 4. Start Turn 2
    game.start_turn() 
    # (Time Wizard should trigger and die)

    # 5. Start Turn 3
    game.start_turn() 
    # (Time Wizard should NOT trigger, as he unsubscribed)